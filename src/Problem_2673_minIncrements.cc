#include <algorithm>
#include <vector>

using namespace std;

// 对于任一叶结点，它的值为 x，它的兄弟节点的值为 y。
// 可以发现，对于树上的其余节点，它们要么同时是这两个叶节点的祖先，要么同时不是这两个叶节点的祖先。
// 对这些节点进行一次操作，要么同时增加了根到这两个叶节点的路径值，要么没有任何效果。
// 因此，要想使得根到这两个叶节点的路径值相等，我们只能增加 x 和 y 本身。

// 由于我们希望操作次数最少，那么应该进行 ∣x−y∣ 次操作，将较小的值增加至与较大的值相等。
// 待考虑完所有叶节点之后，互为兄弟节点的叶节点的值两两相等（并且根到它们的路径值显然也相等）。
// 如果我们还需要操作某个叶节点，那么为了使得路径值相等，它的兄弟节点同样也需要操作。
// 此时就需要两次操作，但不如直接操作它们的双亲节点，可以省去一次操作。

// 因此，所有的叶节点都无需进行操作。我们就可以将它们全部移除。
// 为了使得路径值保持不变，我们可以将叶节点的值增加至它们的双亲节点。
// 这样一来，所有的双亲节点都变成了新的叶节点，我们重复进行上述操作即可。
// 当只剩一个节点（根节点）时，就可以得到最终的答案。

class Solution
{
 public:
  int minIncrements(int n, vector<int>& cost)
  {
    int ans = 0;
    for (int i = n - 2; i > 0; i -= 2)
    {
      ans += std::abs(cost[i] - cost[i + 1]);
      // 叶子结点 i 和 i + 1 的双亲节点下标为 i / 2
      cost[i / 2] += std::max(cost[i], cost[i + 1]);
    }
    return ans;
  }
};
